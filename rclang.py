"""
Simple language that translates to C++11 with garbage collection, like Java
"""


PREFIX = r"""// Autogenerated with -- gclang --
#include <iostream>
#include <string>
#include <memory>
#include <vector>
namespace gclang {
using Int = long long;
using Float = double;
void vvmain();

class CcObject: public std::enable_shared_from_this<CcObject> {};

class CcString: public CcObject {
public:
    const std::string buffer;
    CcString(const std::string &s): buffer(s) {}

    std::shared_ptr<CcString> opadd(std::shared_ptr<CcString> other) {
        return std::make_shared<CcString>(buffer + other->buffer);
    }
};

Int opadd(Int a, Int b) {
    return a + b;
}

template <class A, class B>
auto opadd(std::shared_ptr<A> a, std::shared_ptr<B> b) -> decltype(a->opadd(b)) {
    return a->opadd(b);
}

Int opsub(Int a, Int b) {
    return a - b;
}

std::shared_ptr<CcString> vvstr(Int x) {
    return std::make_shared<CcString>(std::to_string(x));
}

std::shared_ptr<CcString> vvstr(std::shared_ptr<CcString> x) {
    return x;
}

template <class T> void vvprint(T s) {
    std::cout << vvstr(s)->buffer << std::endl;
}
"""  # noqa

POSTFIX = r"""
}  // namespace gclang

int main() {
  gclang::vvmain();
}
"""


openbr = '{'
closebr = '}'
openpar = '('
closepar = ')'
openbk = '['
closebk = ']'

nexttempvarid = [0]


def mktempvarname():
    name = 'tempvar' + str(nexttempvarid[0])
    nexttempvarid[0] += 1
    return name


class Ast(object):
    pass


class Program(Ast):
    def __init__(self, declarations, functions, classes):
        self.declarations = declarations
        self.functions = functions
        self.classes = classes

    def cxx(self):
        return ''.join([
            PREFIX,
            ''.join(c.forward() for c in self.classes),
            ''.join(d.extern() for d in self.declarations),
            ''.join(f.prototype() for f in self.functions),
            ''.join(c.declaration() for c in self.classes),
            ''.join(d.definition() for d in self.declarations),
            ''.join(f.definition() for f in self.functions),
            ''.join(c.definitions() for c in self.classes),
            POSTFIX,
        ])


class Type(Ast):
    pass


class Statement(Ast):
    pass


class Expression(Ast):
    pass


class Declaration(Statement):
    def __init__(self, name, type_, expression):
        self.name = name
        self.type = type_
        self.expression = expression

    def extern(self):
        return ''.join(['\nextern ', self.type.cxx(), ' vv', self.name, ';'])

    def definition(self):
        return ''.join([
            '\n', self.type.cxx(), ' vv', self.name,
            self.expression.cxx() if self.expression else '',
            ';',
        ])


class Class(Ast):
    def __init__(self, name, bases, members, methods):
        self.name = name
        self.bases = bases
        self.members = members
        self.methods = methods

    def forward(self):
        return ''.join([
            'class Cc', self.name, ':',
            ','.join('public virtual ' + t.cxx() for t in self.bases),
            ';\n'
        ])


class Function(Ast):
    def __init__(self, returnType, name, args, body):
        self.returnType = returnType
        self.name = name
        self.args = args
        self.body = body  # Block

    def prototypebase(self):
        return ''.join([
            self.returnType.cxx(), ' vv', self.name,
            '(',
            ','.join(t.cxx() + " vv" + n for (t, n) in self.args),
            ')',
        ])

    def prototype(self):
        return '\n' + self.prototypebase() + ';'

    def definition(self):
        return ''.join([
            '\n', self.prototypebase(),
            self.body.cxx(),
        ])


PRIMITIVE_TYPES = {
    'void': 'void',
    'int': 'Int',
    'float': 'Float',
}


class PrimitiveType(Type):
    def __init__(self, name):
        self.name = name
        if name not in PRIMITIVE_TYPES:
            raise Exception(name + " is not a primitive type")

    def cxx(self):
        return PRIMITIVE_TYPES[self.name]


class ClassType(Type):
    def __init__(self, name):
        self.name = name

    def cxx(self):
        return 'Cc' + self.name


class GenericType(Type):
    def __init__(self, name, args):
        self.name = name
        self.args = args

    def cxx(self):
        return ''.join([
            'Cc', self.name,
            '<', ','.join(arg.cxx() for arg in self.args), '>',
        ])


class ExpressionStatement(Statement):
    def __init__(self, expression):
        self.expression = expression

    def cxx(self):
        return '\n' + self.expression.cxx() + ';'


class Block(Statement):
    def __init__(self, statements):
        self.statements = statements

    def cxx(self):
        return ''.join([
            '\n{',
            ''.join(s.cxx() for s in self.statements).replace('\n', '\n  '),
            '\n}',
        ])


class Name(Expression):
    def __init__(self, name):
        self.name = name

    def cxx(self):
        return 'vv' + self.name


class String(Expression):
    def __init__(self, value):
        self.value = value

    def cxx(self):
        return ''.join([
            'std::make_shared<CcString>('
            '"',
            self.value
                .replace('\\', '\\\\')
                .replace('\t', '\\t')
                .replace('\n', '\\n'),
            '"',
            ')',
        ])


class Int(Expression):
    def __init__(self, value):
        self.value = value

    def cxx(self):
        return str(self.value) + 'll'


class CxxCall(Expression):
    def __init__(self, fname, args):
        self.fname = fname
        self.args = args

    def cxx(self):
        return ''.join([
            self.fname, '(', ', '.join(arg.cxx() for arg in self.args), ')'
        ])


class Call(Expression):
    def __init__(self, f, args):
        self.f = f
        self.args = args

    def cxx(self):
        return ''.join([
            self.f.cxx(), '(', ','.join(arg.cxx() for arg in self.args), ')'
        ])


class Token(object):
    def __init__(self, i, type_, value):
        self.i = i
        self.type = type_
        self.value = value

    def __repr__(self):
        return 'Token(%r, %r)' % (self.type, self.value)


SYMBOLS = list(reversed(sorted([
    '\n', '(', ')', '{', '}', '[', ']',
    '+', '-', '*', '%', '/',
])))


KEYWORDS = {'class', 'include', 'while', 'return'}


def lex(s):
    i = 0
    ps = [openbr]
    ts = []
    ms = {
        openbr: closebr,
        '(': ')',
        '[': ']',
    }

    def nlis():  # newline is space
        return ps[-1] != closebr

    def at_space_or_comment():
        return i < len(s) and (
            ((s[i] != '\n' or nlis()) and s[i].isspace()) or
            s[i] == '#'
        )

    while True:
        # skip spaces and comments
        while at_space_or_comment():
            if s[i] == '#':
                while i < len(s) and s[i] != '\n':
                    i += 1
            else:
                i += 1

        if i >= len(s):
            if len(ps) > 1:
                raise Exception("Unmatched: " + ps[-1])
            ts.append(Token(i, '\n', '\n'))
            ts.append(Token(i, 'EOF', ''))
            break

        j = i

        if any(s.startswith(t, i) for t in SYMBOLS):
            t = next(t for t in SYMBOLS if s.startswith(t, i))
            if t in ms:
                ps.append(t)
            elif t in ms.values():
                if ms[ps.pop()] != t:
                    raise Exception("Mismatched " + t)
            i += len(t)
            ts.append(Token(j, t, t))
            continue

        if s.startswith(('r"', '"', "r'", "'"), i):
            if s[i] == 'r':
                i += 1
            quotes = s[i:i+3] if s.startswith(s[i] * 3, i) else s[i]
            i += len(quotes)
            while i < len(s) and not s.startswith(quotes, i):
                i += 1
            if i >= len(s):
                lineno = 1 + s[:j].count('\n')
                raise Exception(
                    "String literal on line %d not terminated" % lineno)
            i += len(quotes)
            value = eval(s[j:i])
            ts.append(Token(j, 'STRING', value))
            continue

        if s[i].isdigit() or s[i] == '.' and s[i+1:i+2].isdigit():
            while i < len(s) and s[i].isdigit():
                i += 1
            if i < len(s) and s[i] == '.':
                i += 1
                while i < len(s) and s[i].isdigit():
                    i += 1
                ts.append(Token(j, 'FLOAT', float(s[j:i])))
            else:
                ts.append(Token(j, 'INT', int(s[j:i])))
            continue

        if s[i].isalpha() or s[i] == '_':
            while i < len(s) and (s[i].isalnum() or s[i] == '_'):
                i += 1
            value = s[j:i]
            if value in KEYWORDS:
                ts.append(Token(j, value, value))
            elif value in PRIMITIVE_TYPES or value[0].upper() == value[0]:
                ts.append(Token(j, 'TYPENAME', value))
            else:
                ts.append(Token(j, 'NAME', value))
            continue

        while i < len(s) and not s[i].isspace():
            i += 1
        raise Exception("Unrecognized token: " + s[j:i])

    return ts


def parse(s):
    ts = lex(s)
    i = [0]

    def peek():
        return ts[i[0]]

    def gettok():
        t = peek()
        i[0] += 1
        return t

    def at(t):
        return peek().type == t

    def atnl():
        return at('\n') or at(';')

    def expect(t):
        if not peek().type == t:
            raise Exception("Expected %r but got %r" % (t, peek()))
        return gettok()

    def consumenl():
        while atnl():
            gettok()

    def consume(t):
        if peek().type == t:
            return gettok()

    def ptype():
        name = expect('TYPENAME').value
        if name in PRIMITIVE_TYPES:
            return PrimitiveType(name)
        elif consume(openbk):
            args = []
            while not consume(closebk):
                args.append(ptype())
                consume(',')
            return GenericType(name, args)
        else:
            return ClassType(name)

    def pstmt():
        consumenl()
        if at('TYPENAME'):
            type_ = ptype()
            name = expect('NAME').value
            return pdecl(type_, name)
        elif at(openbr):
            return pblock()
        else:
            e = pexpr()
            consumenl()
            return ExpressionStatement(e)

    def pdecl(type_, name):
        expr = pexpr() if consume('=') else None
        return Declaration(type_, name, expr)

    def pblock():
        consumenl()
        expect(openbr)
        consumenl()
        stmts = []
        while not consume(closebr):
            stmts.append(pstmt())
            consumenl()
        return Block(stmts)

    def pfunc(type_, name):
        expect(openpar)
        args = []
        while not consume(closepar):
            t = ptype()
            n = expect('NAME').value
            args.append((t, n))
        body = pblock()
        return Function(type_, name, args, body)

    def pexpr():
        return pexpr2()

    def pexpr2():
        e = pexpr1()
        while True:
            if consume('+'):
                r = pexpr1()
                e = CxxCall('opadd', [e, r])
                continue
            if consume('-'):
                r = pexpr1()
                e = CxxCall('opsub', [e, r])
                continue
            break
        return e

    def pexpr1():
        e = pexpr0()
        while True:
            if consume(openpar):
                args = []
                while not consume(closepar):
                    args.append(pexpr())
                    consume(',')
                e = Call(e, args)
                continue
            break
        return e

    def pexpr0():
        if at('INT'):
            return Int(expect('INT').value)
        if at('NAME'):
            return Name(expect('NAME').value)
        if at('STRING'):
            return String(expect('STRING').value)
        if consume(openpar):
            e = pexpr()
            expect(closepar)
            return e
        raise Exception("Expected expression but found " + repr(peek()))

    def pclass():
        name = expect('NAME').value
        bases = []
        if consume(openpar):
            while not consume(closepar):
                bases.append(ptype())
                consume(',')
        expect(openbr)
        members = []
        methods = []
        consumenl()
        while not consume(closebr):
            type_ = ptype()
            name = expect('NAME').value
            if atnl():
                members.append(pdecl(type_, name))
            else:
                methods.append(pfunc(type_, name))
            consumenl()
        return Class(name, bases, members, methods)

    def pprog():
        decls = []
        funcs = []
        clss = []
        consumenl()
        while not at('EOF'):
            if consume('class'):
                clss.append(pclass())
            else:
                type_ = ptype()
                name = expect('NAME').value
                if at(openpar):
                    funcs.append(pfunc(type_, name))
                else:
                    decls.append(pdecl(type_, name))
            consumenl()
        return Program(decls, funcs, clss)

    return pprog()


def test():
    node = Program(
        [],
        [
            Function(
                PrimitiveType('void'), 'main', [],
                Block([
                    ExpressionStatement(
                        Call(Name('print'), [String('Hello world!')])
                    ),
                    ExpressionStatement(
                        Call(Name('print'), [String('Hello world!')])
                    ),
                ])),
        ],
        [])
    print(node.cxx())


# Simple lex test
s = str(lex(r"""
{} "hello" name 14 92. class
"""))
assert(s == r"[Token('{', '{'), Token('}', '}'), Token('STRING', 'hello'), Token('NAME', 'name'), Token('INT', 14), Token('FLOAT', 92.0), Token('class', 'class'), Token('\n', '\n'), Token('EOF', '')]")  # noqa

n = parse(r"""
void main() {
  print("Hello world!")
  print("a" + "b")
  print(55)
  print(723 + 84)
  print(723 - 84)
}
""")
print(n.cxx())
# test()
